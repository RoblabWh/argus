<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Map</title>
    <!-- adds leaflet -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css"
          integrity="sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A=="
          crossorigin=""/>
    <!-- Make sure you put this AFTER Leaflet's CSS -->
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"
            integrity="sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA=="
            crossorigin=""></script>
    <!-- adds leaflet -->
    <style>
        #map-with-overlay-container {
            width: 100%;
            position: relative;
            height: 900px;
            max-height: 85vh;
            padding-top:30px;
        }

        #map {
            height: 900px;
            max-height: 85vh;
            width: 100%;
            display: flex;
            justify-content: center;
            margin: 0 auto;

            position: absolute;
            top: 0;
            bottom: 0;
        }

        #map-overlay-slider {
            position: absolute;
            bottom: 40px;
            left: 25%;
            width: 50%;
            padding: 10px;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 4px;
            align-items: center;
        }

        #map-overlay-detections-filter-collapsed {
            position: absolute;
            top: 64px;
            right: 10px;
        }

    </style>
</head>
<body>
{% if flight_trajectory %}
<div id="map-with-overlay-container">
    <div id="map"></div>
    <div id="map-overlay-slider">
        <a>
            <label for="mapOverlayOpacityRange" style="margin: 0 0 0 10px; color: var(--font-color-b);">Overlay Opacity</label>
            <input type="range" min="0" max="100" value="100" class="slider" id="mapOverlayOpacityRange" style="margin: 0px 10px; width:35%;">
            <div style="float: right">
                <label style="margin: 0 0 0 10px; color: var(--font-color-b);"> Detections: tactical sign</label>
                <label class="switch">
                    <input type="checkbox" id="mapOverlayStyleCheckbox" checked="checked">
                    <span class="switch-slider round"></span>
                </label>
                <label style="margin: 0 0 0 10px; color: var(--font-color-b);">icon</label>
            </div>
        </a>
    </div>
    <div id="map-overlay-detections-filter">
        <div id="map-overlay-detections-filter-collapsed">

        </div>
        <div id="map-overlay-detections-filter-expanded"></div>
    </div>
</div>


{% endif %}
<script>

// ===========
//Creating map
// ===========

var map = L.map('map')
var coordinatesNamesList = [];

var objectDetectionLayer = null;
var objectDetectionLayer_detail = null;



// =====================================================================
//Generating map layers (styles like a streets map, satellite map, etc.)
// =====================================================================

const mbAttr = 'Map data &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, Imagery Â© <a href="https://www.mapbox.com/">Mapbox</a>';
const mbUrl = 'https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token=pk.eyJ1Ijoicm9ibGFidXNlcndocyIsImEiOiJja3VjaXF3d2MxMTN5Mm9tdmQzaGphdGU3In0.BhKF_054bVOPcviIq2yIKg';

const streets = L.tileLayer(mbUrl, {
    maxZoom: 25,
    id: 'mapbox/streets-v11',
    tileSize: 512,
    zoomOffset: -1,
    attribution: mbAttr
});

const osm = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 25,
    attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
});

const satellite = L.tileLayer(mbUrl, {
    maxZoom: 25,
    id: 'mapbox/satellite-v9',
    tileSize: 512,
    zoomOffset: -1,
    attribution: mbAttr
});

const baseLayers = {
    'OpenStreetMap': osm,
    'Streets': streets,
    'Satellite': satellite
};






// ===============================================================================
// Generating map Overlays (images) based on the maps generated by the imageMapper
// ===============================================================================


{% for map in maps %}

var imageBounds{{map.name}} = {{map.bounds}};
var mapSize{{map.name}} = {{map.size}};
var center{{map.name}} = {{map.center}};
var imageOverlay{{map.name}} = L.imageOverlay('{{ global_for(map.file) }}', imageBounds{{map.name}});
var {{map.name}}Overlay = L.layerGroup([imageOverlay{{map.name}}]);

var lat1{{map.name}} = imageBounds{{map.name}}[0][0];
var long1{{map.name}} = imageBounds{{map.name}}[0][1];
var lat2{{map.name}} = imageBounds{{map.name}}[1][0];
var long2{{map.name}} = imageBounds{{map.name}}[1][1];
{% if not map.odm %}
var coordinates{{map.name}} = {{map.image_coordinates | tojson}};
{% endif %}

function set{{map.name}}MapImage(path) {
    imageOverlay{{map.name}}.setUrl(path);
}

function update{{map.name}}Map(map) {
    console.log("updating map {{map.name}}");
    mapSize{{map.name}} = map.size;
    center{{map.name}} = map.center;
    set{{map.name}}MapImage(map.file_url);
    set{{map.name}}Bounds(map.bounds);
    {% if not map.odm %}
    coordinates{{map.name}} = map.image_coordinates;


    if(map.image_coordinates!= null) {
        updateCoordinatesNamesList({{loop.index0}}, coordinates{{map.name}});
        loadPolygons{{map.name}}(map.image_coordinates);
    }
    {% endif %}
    showCurrentSlide();
}

function set{{map.name}}Bounds(bounds) {
    imageOverlay{{map.name}}.setBounds(bounds);
    var imageBounds{{map.name}} = bounds;
    lat1{{map.name}} = imageBounds{{map.name}}[0][0];
    long1{{map.name}} = imageBounds{{map.name}}[0][1];
    lat2{{map.name}} = imageBounds{{map.name}}[1][0];
    long2{{map.name}} = imageBounds{{map.name}}[1][1];
}


{% if not map.odm %}
var polygons{{map.name}};
function loadPolygons{{map.name}}(coordinates) {
    console.log("loading polygons");
    polygons{{map.name}} = new Array();
    //var centers{{map.name}} = new Array();
    for (var i = 0; i < coordinates.length; i++) {
        var polygonString = coordinates[i].coordinates_string;
        if(polygonString =="") {
            continue;
        }
        var points_strings = polygonString.split(',');
        var points = new Array();
        for (var j = 0; j < points_strings.length; j++) {
            var point = points_strings[j].split(' ');
            points.push([parseInt(point[0]), parseInt(point[1])]);
        }
        if(typeof(mapSize{{map.name}}[0]) == 'string') {
            var arr = new Array();
            arr.push(parseInt(mapSize{{map.name}}[0]));
            arr.push(parseInt(mapSize{{map.name}}[1]));
            mapSize{{map.name}} = arr;
        }
        var p1=[points[0][0]/mapSize{{map.name}}[0],points[0][1]/mapSize{{map.name}}[1]];
        var p2=[points[1][0]/mapSize{{map.name}}[0],points[1][1]/mapSize{{map.name}}[1]];
        var p3=[points[2][0]/mapSize{{map.name}}[0],points[2][1]/mapSize{{map.name}}[1]];
        var p4=[points[3][0]/mapSize{{map.name}}[0],points[3][1]/mapSize{{map.name}}[1]];
        var pL1 = [p1[1] * lat1{{map.name}} + ((1 - p1[1]) * lat2{{map.name}}), p1[0] * long2{{map.name}} + ((1 - p1[0]) * long1{{map.name}})];
        var pL2 = [p2[1] * lat1{{map.name}} + ((1 - p2[1]) * lat2{{map.name}}), p2[0] * long2{{map.name}} + ((1 - p2[0]) * long1{{map.name}})];
        var pL3 = [p3[1] * lat1{{map.name}} + ((1 - p3[1]) * lat2{{map.name}}), p3[0] * long2{{map.name}} + ((1 - p3[0]) * long1{{map.name}})];
        var pL4 = [p4[1] * lat1{{map.name}} + ((1 - p4[1]) * lat2{{map.name}}), p4[0] * long2{{map.name}}+ ((1 - p4[0]) * long1{{map.name}})];
        var latlngs = [pL1,pL2,pL3,pL4];
        //var center = [((pL1[0] + pL3[0]) / 2.0), ((pL1[1] + pL3[1]) / 2.0)];
        //centers{{map.name}}.push(center);
        var polygon = L.polygon(latlngs ,{ opacity: 0, fillOpacity: 0.0, fillColor: '#0000FF' });
        polygon.on('mouseover', highlightFeature);
        polygon.on('mouseout', resetHighlight);
        polygon.on('click',	slide{{map.name}});
        {{map.name}}Overlay.addLayer(polygon);

        polygons{{map.name}}.push(polygon);
    }

}
function slide{{map.name}}(e) {
	var i = polygons{{ map.name }}.indexOf(e.target);
	filename = coordinates{{ map.name }}[i].file_name;
	showSlideByFilename(filename);
}
{% endif %}
{% endfor %}







// ============================================================================
// Add the layer control to the map to switch between overlays and display them
// ============================================================================

var layerSwitcher = {
    {% for map in maps %}
    '{{map.name}}_Map': {{map.name}}Overlay,
    {% endfor %}
};

const mapAnnotationsSwitcher = {};

//var layerControl2 = L.control.layers({}, mapAnnotationsSwitcher).addTo(map);


var layerControl = L.control.layers(baseLayers, layerSwitcher,{}, {collapsed: false}).addTo(map);
satellite.addTo(map);

drawFlightTrajectory({{ flight_trajectory |tojson }});

{% if maps[0] %}
layerSwitcher.{{maps[0].name}}_Map.addTo(map);
{% endif %}






// =================================================
// Add the zoom control to the map with a home point
// =================================================

var defaultZoom = map.getZoom();
{% if maps[0] %}
var center = {{maps[0].center}};
{% else %}
var center = map.getCenter();
{% endif %}


L.Control.zoomHome = L.Control.extend({
    options: {
        position: 'topleft',
        zoomHomeText: '&#9873;',
        zoomHomeTitle: 'Zoom home'
    },
    onAdd: function (map) {
        var controlName = 'gin-control-zoom',
        container = L.DomUtil.create('div', controlName + ' leaflet-bar'),
        options = this.options;
        //container.innerHTML
        this._zoomHomeButton = this._createButton(options.zoomHomeText, options.zoomHomeTitle,
        controlName + '-home', container, this._zoomHome);
        return container;
    },
    onRemove: function (map) {
    },
    _zoomHome: function (e) {
        map.flyTo(center, defaultZoom);
    },
    _createButton: function (html, title, className, container, fn) {
        var link = L.DomUtil.create('a', className, container);
        link.innerHTML = html;
        link.href = '#';
        link.title = title;
        link.role = "button";
        L.DomEvent
            .on(link, 'click', fn, this)
            .on(link, 'click', L.DomEvent.stop)
            .on(link, 'click', this._refocusOnMap, this);;
        return link;
    },
});
var zoomHome = new L.Control.zoomHome();
zoomHome.addTo(map);






// =============
// map functions
// =============

function drawFlightTrajectory(coordinates){
    var latlngs = [];
    for (var i = 0; i < coordinates.length; i++) {
        latlngs.push([parseFloat(coordinates[i][0]), parseFloat(coordinates[i][1])]);
    }

    trajectory = L.polyline(latlngs, {color: 'fuchsia'}).addTo(map);
    var overlay = {
        'Gpx': trajectory
    };
    var gpxLayer = L.control.layers(null, overlay, {
        collapsed: false,
        position: 'topleft'
    });
    layerControl.addOverlay(trajectory, 'Trajectory');
    // set view based on trajectory overlay
    map.fitBounds(trajectory.getBounds());
}

var mapOverlayOpacity = 1;
var threshold = 0.55;

function highlightFeature(e) {
	if(mapOverlayOpacity > threshold) {
		var layer = e.target;
		layer.setStyle({
			fillOpacity: 0.7
		});
	}
}

function resetHighlight(e) {
	var layer = e.target;

	layer.setStyle({
		fillOpacity: 0.0
	});
}


function changeAlpha(value) {
    {% for map in maps %}
    imageOverlay{{map.name}}.setOpacity(value/100);
    {% endfor %}

    //mapImage.setOpacity(value/100);
    {% if has_ir %}
    //IR.setOpacity(value/100);
    {% endif %}
    mapOverlayOpacity = value/100;
}






// =====================
// Map markers for Panos
// =====================

{% if panos %}
{% for pano in panos %}
{% if pano.coordinates %}

marker{{ loop.index0  }} = L.marker({{pano.coordinates}}, {clickable: true});
marker{{ loop.index0  }}.on("click", function(e) { show_pano({{ loop.index0 }}); });
marker{{ loop.index0  }}.addTo(map);
{% endif %}
{% endfor %}
{% endif %}


{% for map in maps %}
{% if not map.odm %}
{% if map.image_coordinates %}
coordinates{{map.name}} = {{ map.image_coordinates|tojson }};
loadPolygons{{map.name}}({{ map.image_coordinates|tojson }});
updateCoordinatesNamesList({{loop.index0}}, coordinates{{map.name}});

{% endif %}
{% endif %}
{% endfor %}

$('#mapOverlayOpacityRange').on('input', function() {
    changeAlpha($(this).val());
});

console.log("map loaded");






// =====
// other
// =====

function updateCoordinatesNamesList(index, coordinates){
    var namesList = [];
    for (var i = 0; i < coordinates.length; i++) {
        namesList.push(coordinates[i].file_name);
    }
    if(coordinatesNamesList.length < index){
        coordinatesNamesList[index] = namesList;
    }
    else{
        coordinatesNamesList.push(namesList);
    }
}

function isUsedInMap(index, displayingIR){
    console.log("isUsedInMap ?");
    var filename = "";
    if (displayingIR){
         filename = getFilePathBySlideIndex(index, 1);
    }
    else{
         filename = getFilePathBySlideIndex(index, 0);
    }

    for (var i = 0; i < coordinatesNamesList.length; i++) {
        list = coordinatesNamesList[i];
        if(list.indexOf(filename) > -1){
            return true;
        }
    }
    return false;
}

$('#mapOverlayStyleCheckbox').change(function(){
    if (detections != null){
        if (objectDetectionLayer != null){
            generateObjectDetectionLayer(detections);
        }
    }
});

function generateObjectDetectionLayer(objectDetectionData){

    let layer_visibility = map.hasLayer(objectDetectionLayer);
    if(objectDetectionLayer != null){
        map.removeLayer(objectDetectionLayer);
        layerControl.removeLayer(objectDetectionLayer);
    }
    else{
        const ObjectDetectionControl = L.Control.extend({
            options: {
                detections: {}
            },

            initialize: function(options) {
                L.Util.setOptions(this, options);
            },

            onAdd: function(map) {
                const container = L.DomUtil.create('div', 'custom-control');

                let htmlContent = `
                    <div class="leaflet-control-layers leaflet-touch">
                    <a id="map-overlay-detections-filter-activator" class="leaflet-control-layers-toggle" title="detections" href="#" style="background-image: url(/static/default/ObjectDetectionIcon.png); background-repeat: no-repeat; background-size: 80%;"></a>
                    <div id="map-overlay-detections-filter-expanded" class="leaflet-control-layers-expanded leaflet-control-layers" style="display:none";>
                    <section class="leaflet-control-layers-list">
                    `;
                for (var i = 0; i < detections["categories"].length; i++) {
                    name = detections["categories"][i]["name"];
                    //try to get the global slider, if it does not exist, skip this category
                    if (document.getElementById("slider_" + name + "_global_threshold")){
                        htmlContent += `
                            <div style="display: flex; width: 100%">
                                <input type="checkbox" id="${name}-checkbox-map"}>
                                <label for="${name}-checkbox-map">${name}</label>
                                <input type="range" id="${name}-slider-map" min="0" max="1" step="0.01" value="0.75" style="width:150px; margin-left: auto;">
                            </div>
                            `;
                    }
                }
                htmlContent += `
                </section>
                </div>
                </div>
                `;


                container.innerHTML = htmlContent;

                // Prevent map click events from being triggered on the control container
                L.DomEvent.disableClickPropagation(container);

                // add on mouseenter event to show the expanded filter
                L.DomEvent.on(container.querySelector('#map-overlay-detections-filter-activator'), 'mouseenter', function() {
                    container.querySelector('#map-overlay-detections-filter-expanded').style.display = 'block';
                    container.querySelector('#map-overlay-detections-filter-activator').style.display = 'none';
                });

                // add on mouseleave event to hide the expanded filter
                L.DomEvent.on(container.querySelector('#map-overlay-detections-filter-expanded'), 'mouseleave', function() {
                    container.querySelector('#map-overlay-detections-filter-expanded').style.display = 'none';
                    container.querySelector('#map-overlay-detections-filter-activator').style.display = 'block';
                });

                // Event listeners for checkbox and slider changes
                for (var i = 0; i < detections["categories"].length; i++) {
                    name = detections["categories"][i]["name"];

                    if (document.getElementById("slider_" + name + "_global_threshold")){
                        //Set checkbox to be checked by default
                        container.querySelector(`#${name}-checkbox-map`).checked = true;
                        L.DomEvent.on(container.querySelector(`#${name}-checkbox-map`), 'change', this.toggleVisibilityDetection, this);
                        L.DomEvent.on(container.querySelector(`#${name}-slider-map`), 'input', this.updateThresholdDetection, this);
                    }
                }

                return container;
            },

            toggleVisibilityDetection: function(event) {
                //const category = event.target.id.replace('-checkbox', '');
                //detections[category].visible = event.target.checked;

                draw_individual_objects_on_map(detections);

                // Update map based on visibility changes
                // Implement this part based on your specific use case
            },

            updateThresholdDetection: function(event) {

                name = event.target.id.split("-")[0];
                global_slider = document.getElementById("slider_" + name + "_global_threshold");
                global_slider.value = event.target.value;
                global_slider.dispatchEvent(new Event('change', { bubbles: true }));

            }
        });

        // Add the custom control to the map
        (new ObjectDetectionControl(objectDetectionData)).addTo(map);
    }




    // generate a new layer
    objectDetectionLayer = L.layerGroup();


    //loop over all detections and collect found object types per image using image_id as key
    foundObjectsByImageID = {};

    let category_visibilities = {};
    for (var i = 0; i < objectDetectionData["categories"].length; i++) {
        name = objectDetectionData["categories"][i]["name"];
        var checkbox = document.getElementById(name + "-checkbox-map");
        if(checkbox != null){
            category_visibilities[name] = checkbox.checked;
        }
    }

    for(var i=0; i< objectDetectionData.annotations.length; i++){
        imageID = objectDetectionData.annotations[i].image_id;
        categoryID = objectDetectionData.annotations[i].category_id;
        score = objectDetectionData.annotations[i].score;
        category = objectDetectionData.categories[categoryID - 1];
        var slider = document.getElementById("slider_" + category.name + "_global_threshold");
        if(slider == null){
            continue;
        }
        var threshold = slider.value;
        if(score < threshold){
            continue;
        }

        if(imageID in foundObjectsByImageID){
            //check if categoryID is already in list
            if(foundObjectsByImageID[imageID].indexOf(categoryID) > -1){
                continue;
            }
            foundObjectsByImageID[imageID].push(categoryID);
        }
        else{
            foundObjectsByImageID[imageID] = [categoryID];
        }
    }

    //now loop over all images and add the fitting marker to the layer
    for(var i=0; i< coordinatesRGB.length; i++){
        let filename_long = coordinatesRGB[i].file_name;
        filename = filename_long.split("/").pop();
        let polygonString = coordinatesRGB[i].coordinates_string;
        let points_strings = polygonString.split(',');
        let points = new Array();
        for (var j = 0; j < points_strings.length; j++) {
            let point = points_strings[j].split(' ');
            points.push([parseInt(point[0]), parseInt(point[1])]);
            points[j][0] = (points[j][0] / mapSizeRGB[0] * long2RGB) + ((1 - points[j][0] / mapSizeRGB[0]) * long1RGB);
            points[j][1] = (points[j][1] / mapSizeRGB[1] * lat1RGB) + ((1 - points[j][1] / mapSizeRGB[1]) * lat2RGB);
            //Swap lat and long
            let temp = points[j][0];
            points[j][0] = points[j][1];
            points[j][1] = temp;
        }
        let center = [((points[0][0] + points[2][0]) / 2.0), ((points[0][1] + points[2][1]) / 2.0)];

        let imageID = -1;
        images = objectDetectionData.images;
        //get image.id from images
        for(var j=0; j< images.length; j++){
            if(images[j].file_name == filename){
                imageID = images[j].id;
                break;
            }
        }
        if(imageID == -1){
            //add white circle as marker
            marker = L.circle(center, {
                color: 'white',
                fillColor: 'white',
                fillOpacity: 0.5,
                radius: 2
            }).addTo(map);

            continue;
        }
        let icon_filename = ''
        //add an image marker based on the found object categories
        if(imageID in foundObjectsByImageID){
            foundCategoriesInImage = foundObjectsByImageID[imageID];
            if(foundCategoriesInImage.indexOf(1) > -1){
                if(category_visibilities['fire']){
                    icon_filename = icon_filename + 'Brand';
                }
            }
            if(foundCategoriesInImage.indexOf(2) > -1){
                if(category_visibilities['vehicle']){
                    icon_filename = icon_filename + 'Fahrzeug';
                }
            }
            if(foundCategoriesInImage.indexOf(3) > -1){
                if(category_visibilities['human']){
                    icon_filename = icon_filename + 'Person';
                }
            }
        }

        if (icon_filename == ''){
            //add white circle as marker
            marker = L.circle(center, {
                color: 'white',
                fillColor: 'white',
                fillOpacity: 0.5,
                radius: 2
            }).addTo(objectDetectionLayer);
            continue;
        }

        checkbox = document.getElementById("mapOverlayStyleCheckbox");
        if(checkbox.checked){
            detectionIconStyleSetting = 'icon'; //'taktischeZeichen' or 'icon'
            detectionIconSize = 50;
        }
        else{
            detectionIconStyleSetting = 'taktischeZeichen'; //'taktischeZeichen' or 'icon'
            detectionIconSize = 40;
        }

        marker = L.marker(center, {
            icon: L.icon({
                iconUrl: '/static/default/signs/' + detectionIconStyleSetting + '/' + icon_filename + '.png',
                iconSize: [detectionIconSize, detectionIconSize],
                iconAnchor: [detectionIconSize/2, detectionIconSize/2],
                popupAnchor: [0, 0],
                shadowUrl: null,
                shadowSize: null,
                shadowAnchor: null
            })
        });
        marker.on('click',	function(){showSlideByFilename(filename_long)});
        marker.addTo(objectDetectionLayer);
    }

    //add layer to map
    if(layer_visibility){
        objectDetectionLayer.addTo(map);
    }
    layerControl.addOverlay(objectDetectionLayer , 'taktischeZeichen');
    draw_individual_objects_on_map(objectDetectionData);
}

function draw_individual_objects_on_map(objectDetectionData){
    //check if Layer already exists
    if(objectDetectionLayer_detail != null){
        map.removeLayer(objectDetectionLayer_detail);
        //layerControl2.removeLayer(objectDetectionLayer_detail);
    }

    objectDetectionLayer_detail = L.layerGroup();
    objectDetectionLayer_detail.addTo(map);

    let detections = objectDetectionData.annotations;
    let images = objectDetectionData.images;

    global_thresholds = get_global_thresholds();
    let category_visibilities = {};

    for (var i = 0; i < objectDetectionData["categories"].length; i++) {
        name = objectDetectionData["categories"][i]["name"];
        var checkbox = document.getElementById(name + "-checkbox-map");
        if(checkbox != null){
            category_visibilities[name] = checkbox.checked;
        }
    }

    for(var i=0; i < detections.length; i++){
        let detection = detections[i];
        let categoryID = detection.category_id;
        let imageID = detection.image_id;
        let category = objectDetectionData["categories"][detection.category_id-1]["name"];
        let score = detection.score;


        if(category_visibilities[category] == false){
            continue;
        }

        if(score < global_thresholds[categoryID-1]){
            continue;
        }

        let image = images[detection.image_id];
        let filename = image.file_name;
        let image_size = [image.width, image.height];
        let object_bounds = detection.bbox;
        let object_center_gps = get_object_detection_coordinate(filename, object_bounds, image_size, detection.image_id);

        if(object_center_gps == null){
            continue;
        }

        let color = 'white';
        if(categoryID == 1){
            color = 'red';
        }
        else if(categoryID == 2){
            color = 'black';
        }
        else if(categoryID == 3){
            color = 'blue';
        }

        marker = L.circle(object_center_gps, {
            color: 'white',
            fillColor: color,
            fillOpacity: 0.9,
            radius: 2
        }).addTo(objectDetectionLayer_detail);

        marker.on('click', function(){showImageByFileName(filename)});
    }

    //layerControl2.addOverlay(objectDetectionLayer_detail , 'taktischeZeichen_positioniert');
}

function get_object_detection_coordinate(filename, object_bounds, image_size, image_id){
    if(mapSizeRGB == null){
        return null;
    }

    image_index = -1;

    if(coordinatesRGB.length > image_id){
        let long_name = coordinatesRGB[image_id].file_name;
        let short_name = long_name.split("/").pop();
        if(short_name == filename){
            image_index = image_id;
        }
    }

    if(image_index == -1){
        for(var i=0; i< coordinatesRGB.length; i++){
            let long_name = coordinatesRGB[i].file_name;
            let short_name = long_name.split("/").pop();
            if(short_name == filename){
                image_index = i;
                break;
            }
        }
    }

    if(image_index == -1){
        return null;
    }

    let coordinates_string = coordinatesRGB[image_index].coordinates_string;

    let points_strings = coordinates_string.split(',');
    let image_bounds_gps = new Array();

    for (var j = 0; j < points_strings.length; j++) {
        let point = points_strings[j].split(' ');
        image_bounds_gps.push([parseInt(point[0]), parseInt(point[1])]);
        image_bounds_gps[j][0] = (image_bounds_gps[j][0] / mapSizeRGB[0] * long2RGB) + ((1 - image_bounds_gps[j][0] / mapSizeRGB[0]) * long1RGB);
        image_bounds_gps[j][1] = (image_bounds_gps[j][1] / mapSizeRGB[1] * lat1RGB) + ((1 - image_bounds_gps[j][1] / mapSizeRGB[1]) * lat2RGB);
        //Swap lat and long
        let temp = image_bounds_gps[j][0];
        image_bounds_gps[j][0] = image_bounds_gps[j][1];
        image_bounds_gps[j][1] = temp;
    }

    let object_center_gps = new Array();

    let object_center_px = [object_bounds[0], object_bounds[1]];
    let factor_w = 1 - (object_center_px[0] / image_size[0]);
    let factor_h = 1 - (object_center_px[1] / image_size[1]);


    let u = [image_bounds_gps[3][0] - image_bounds_gps[0][0], image_bounds_gps[3][1] - image_bounds_gps[0][1]];
    let v = [image_bounds_gps[1][0] - image_bounds_gps[0][0], image_bounds_gps[1][1] - image_bounds_gps[0][1]];

    object_center_gps.push(image_bounds_gps[0][0] + (u[0] * factor_w) + (v[0] * factor_h));
    object_center_gps.push(image_bounds_gps[0][1] + (u[1] * factor_w) + (v[1] * factor_h));


    return object_center_gps;
}



</script>
</body>
</html>
